<?xml version="1.0"?>
<doc>
    <assembly>
        <name>DotNetLibrary.Core</name>
    </assembly>
    <members>
        <member name="T:Microsoft.AspNetCore.Components.IUpdateNotifier">
            <summary>
            Interface defining a property for triggering user defined 
            events before the <see cref="M:Microsoft.AspNetCore.Components.ComponentBase.StateHasChanged"/>
            method.
            </summary>
        </member>
        <member name="E:Microsoft.AspNetCore.Components.IUpdateNotifier.OnUpdate">
            <summary>
            Custom events called before 
            <see cref="M:Microsoft.AspNetCore.Components.ComponentBase.StateHasChanged"/>
            has been called.
            </summary>
        </member>
        <member name="T:Microsoft.AspNetCore.Components.IUpdateNotifier`1">
            <inheritdoc cref="T:Microsoft.AspNetCore.Components.IUpdateNotifier"/>
            <typeparam name="TIn">User defined value passed in during updates.</typeparam>
        </member>
        <member name="E:Microsoft.AspNetCore.Components.IUpdateNotifier`1.OnUpdate">
            <inheritdoc cref="T:Microsoft.AspNetCore.Components.IUpdateNotifier"/>
        </member>
        <member name="T:Microsoft.AspNetCore.Components.IUpdateNotifier`2">
            <inheritdoc cref="T:Microsoft.AspNetCore.Components.IUpdateNotifier"/>
            <typeparam name="TIn">User defined value passed in during updates.</typeparam>
            <typeparam name="TOut">User defined type returned from updates.</typeparam>
        </member>
        <member name="E:Microsoft.AspNetCore.Components.IUpdateNotifier`2.OnUpdate">
            <inheritdoc cref="T:Microsoft.AspNetCore.Components.IUpdateNotifier"/>
        </member>
        <member name="T:Microsoft.AspNetCore.Components.UpdateComponent`1">
            <summary>
            Update component base. This can be used to replace the
            <see cref="T:Microsoft.AspNetCore.Components.ComponentBase"/> of a razor file. When using
            <code>@inhert <see cref="T:Microsoft.AspNetCore.Components.UpdateComponent`1"/></code>
            in a razor file, the <typeparamref name="TComponent"/> 
            will be injected into the component and using the 
            <see cref="M:Microsoft.AspNetCore.Components.ComponentBase.OnInitialized"/> method, hook
            into the event Action callback of the component.
            When disposed, the hook will be removed by calling the 
            <see cref="M:System.IDisposable.Dispose"/> method.
            </summary>
            <typeparam name="TComponent">An injectable service that implments the <seealso cref="T:Microsoft.AspNetCore.Components.IUpdateNotifier"/>.</typeparam>
        </member>
        <member name="P:Microsoft.AspNetCore.Components.UpdateComponent`1.Component">
            <summary>
            The component associate with the razor file. This
            is likley a state object used between multiple 
            razor components and handles changes made to the state.
            </summary>
        </member>
        <member name="M:Microsoft.AspNetCore.Components.UpdateComponent`1.OnInitialized">
            <seealso cref="M:Microsoft.AspNetCore.Components.ComponentBase.OnInitialized"/>
        </member>
        <member name="M:Microsoft.AspNetCore.Components.UpdateComponent`1.Update">
            <inheritdoc cref="M:Microsoft.AspNetCore.Components.UpdateComponent`3.Update(`1)"/>
        </member>
        <member name="M:Microsoft.AspNetCore.Components.UpdateComponent`1.Dispose">
            <seealso cref="M:System.IDisposable.Dispose"/>
        </member>
        <member name="T:Microsoft.AspNetCore.Components.UpdateComponent`2">
            <summary>
            Update component base. This can be used to replace the
            <see cref="T:Microsoft.AspNetCore.Components.ComponentBase"/> of a razor file. When using
            <code>@inhert <see cref="T:Microsoft.AspNetCore.Components.UpdateComponent`2"/></code>
            in a razor file, the <typeparamref name="TComponent"/> 
            will be injected into the component and using the 
            <see cref="M:Microsoft.AspNetCore.Components.ComponentBase.OnInitialized"/> method, hook
            into the event Action callback of the component.
            When disposed, the hook will be removed by calling the 
            <see cref="M:System.IDisposable.Dispose"/> method.
            </summary>
            <typeparam name="TComponent">An injectable service that implments the <seealso cref="T:Microsoft.AspNetCore.Components.IUpdateNotifier`1"/>.</typeparam>
            <typeparam name="TIn">The user defined type passed into the <see cref="M:Microsoft.AspNetCore.Components.UpdateComponent`2.Update(`1)"/> method.</typeparam>
        </member>
        <member name="P:Microsoft.AspNetCore.Components.UpdateComponent`2.Component">
            <summary>
            The component associate with the razor file. This
            is likley a state object used between multiple 
            razor components and handles changes made to the state.
            </summary>
        </member>
        <member name="M:Microsoft.AspNetCore.Components.UpdateComponent`2.OnInitialized">
            <seealso cref="M:Microsoft.AspNetCore.Components.ComponentBase.OnInitialized"/>
        </member>
        <member name="M:Microsoft.AspNetCore.Components.UpdateComponent`2.Update(`1)">
            <inheritdoc cref="M:Microsoft.AspNetCore.Components.UpdateComponent`3.Update(`1)"/>
        </member>
        <member name="M:Microsoft.AspNetCore.Components.UpdateComponent`2.Dispose">
            <seealso cref="M:System.IDisposable.Dispose"/>
        </member>
        <member name="T:Microsoft.AspNetCore.Components.UpdateComponent`3">
            <summary>
            Update component base. This can be used to replace the
            <see cref="T:Microsoft.AspNetCore.Components.ComponentBase"/> of a razor file. When using
            <code>@inhert <see cref="T:Microsoft.AspNetCore.Components.UpdateComponent`3"/></code>
            in a razor file, the <typeparamref name="TComponent"/> 
            will be injected into the component and using the 
            <see cref="M:Microsoft.AspNetCore.Components.ComponentBase.OnInitialized"/> method, hook
            into the event Action callback of the component.
            When disposed, the hook will be removed by calling the 
            <see cref="M:System.IDisposable.Dispose"/> method.
            </summary>
            <typeparam name="TComponent">An injectable service that implments the <seealso cref="T:Microsoft.AspNetCore.Components.IUpdateNotifier`1"/>.</typeparam>
            <typeparam name="TIn">The user defined type passed into the <see cref="M:Microsoft.AspNetCore.Components.UpdateComponent`3.Update(`1)"/> method.</typeparam>
            <typeparam name="TOut">The user defined type returned back from a call to the <see cref="M:Microsoft.AspNetCore.Components.UpdateComponent`3.Update(`1)"/> method.</typeparam>
        </member>
        <member name="P:Microsoft.AspNetCore.Components.UpdateComponent`3.Component">
            <summary>
            The component associate with the razor file. This
            is likley a state object used between multiple 
            razor components and handles changes made to the state.
            </summary>
        </member>
        <member name="M:Microsoft.AspNetCore.Components.UpdateComponent`3.OnInitialized">
            <seealso cref="M:Microsoft.AspNetCore.Components.ComponentBase.OnInitialized"/>
        </member>
        <member name="M:Microsoft.AspNetCore.Components.UpdateComponent`3.Update(`1)">
            <summary>
            Method triggered when an update event happens.
            </summary>
            <param name="value">User defined response value.</param>
            <returns>User defined response object.</returns>
        </member>
        <member name="M:Microsoft.AspNetCore.Components.UpdateComponent`3.Dispose">
            <seealso cref="M:System.IDisposable.Dispose"/>
        </member>
        <member name="T:Microsoft.AspNetCore.Http.BasicCookie`1">
            <summary>
            Basic cookie accessor.
            </summary>
        </member>
        <member name="P:Microsoft.AspNetCore.Http.BasicCookie`1.Manager">
            <inheritdoc cref="T:Microsoft.AspNetCore.Http.BasicCookieManager" />
        </member>
        <member name="P:Microsoft.AspNetCore.Http.BasicCookie`1.CookieKey">
            <summary>
            Cookie key name.
            </summary>
        </member>
        <member name="M:Microsoft.AspNetCore.Http.BasicCookie`1.#ctor(Microsoft.AspNetCore.Http.BasicCookieManager,System.String,Microsoft.AspNetCore.Http.CookieOptions)">
            <summary>
            Constructor that takes a manager and cookie key.
            </summary>
            <param name="manager">A cookie manager for accessing the underlying cookies.</param>
            <param name="cookieKey">The key of the cookie.</param>
            <param name="options"><seealso cref="T:Microsoft.AspNetCore.Http.CookieOptions" /></param>
        </member>
        <member name="M:Microsoft.AspNetCore.Http.BasicCookie`1.SetAsync(`0)">
            <summary>
            Set the cookie value using the manager and the constructor cookie key.
            </summary>
            <param name="value">Cookie value.</param>
        </member>
        <member name="M:Microsoft.AspNetCore.Http.BasicCookie`1.DeleteAsync">
            <summary>
            Delete cookie using manager and using the constructor cookie key.
            </summary>
        </member>
        <member name="M:Microsoft.AspNetCore.Http.BasicCookie`1.GetAsync(System.Boolean)">
            <summary>
            Get cookie from cookie manager using the constructor cookie key.
            </summary>
            <param name="allowNull">If a null value is allowed or not.</param>
            <returns>The string value of the cookie.</returns>
        </member>
        <member name="T:Microsoft.AspNetCore.Http.BasicCookieManager">
            <summary>
            Manager for getting, setting, and deleting cookies.
            </summary>
        </member>
        <member name="P:Microsoft.AspNetCore.Http.BasicCookieManager.Runtime">
            <inheritdoc cref="T:Microsoft.JSInterop.IJSRuntime" />
        </member>
        <member name="P:Microsoft.AspNetCore.Http.BasicCookieManager.Context">
            <inheritdoc cref="T:Microsoft.AspNetCore.Http.HttpContext" />
        </member>
        <member name="P:Microsoft.AspNetCore.Http.BasicCookieManager.Logger">
            <inheritdoc cref="T:Serilog.ILogger"/>
        </member>
        <member name="P:Microsoft.AspNetCore.Http.BasicCookieManager.RuntimeContextType">
            <summary>
            Returns the type of the underlying cookie management.
            Either <seealso cref="T:Microsoft.JSInterop.IJSRuntime" /> 
            or <seealso cref="T:Microsoft.AspNetCore.Http.HttpContext" /> 
            and <seealso cref="T:Microsoft.AspNetCore.Authentication.Cookies.ChunkingCookieManager" />.
            </summary>
        </member>
        <member name="M:Microsoft.AspNetCore.Http.BasicCookieManager.#ctor(Serilog.ILogger,System.String,Microsoft.JSInterop.IJSRuntime,Microsoft.AspNetCore.Http.HttpContext,Microsoft.AspNetCore.Authentication.Cookies.ChunkingCookieManager)">
            <summary>
            Create the underlying parent cookie manager.
            </summary>
            <param name="logger"><inheritdoc cref="T:Serilog.ILogger"/>.</param>
            <param name="type">The name of either <seealso cref="T:Microsoft.JSInterop.IJSRuntime" /> or <seealso cref="T:Microsoft.AspNetCore.Http.HttpContext" /></param>
            <param name="runtime"><inheritdoc cref="T:Microsoft.JSInterop.IJSRuntime"/></param>
            <param name="context"><inheritdoc cref="T:Microsoft.AspNetCore.Http.HttpContext"/></param>
            <param name="manager"><inheritdoc cref="T:Microsoft.AspNetCore.Authentication.Cookies.ChunkingCookieManager"/></param>
        </member>
        <member name="M:Microsoft.AspNetCore.Http.BasicCookieManager.AppendResponseCookieAsync(System.String,System.String,Microsoft.AspNetCore.Http.CookieOptions)">
            <summary>
            Create a cookie.
            </summary>
            <param name="key">The key of the cookie.</param>
            <param name="value">The value to set the cookie to or delete if null.</param>
            <param name="options"><inheritdoc cref="T:Microsoft.AspNetCore.Http.CookieOptions"/></param>
        </member>
        <member name="M:Microsoft.AspNetCore.Http.BasicCookieManager.AppendResponseCookieAsync(Microsoft.JSInterop.IJSRuntime,System.String,System.String,Microsoft.AspNetCore.Http.CookieOptions)">
            <inheritdoc cref="M:Microsoft.AspNetCore.Http.BasicCookieManager.AppendResponseCookieAsync(System.String,System.String,Microsoft.AspNetCore.Http.CookieOptions)" />
        </member>
        <member name="M:Microsoft.AspNetCore.Http.BasicCookieManager.AppendResponseCookieAsync(Microsoft.AspNetCore.Http.HttpContext,System.String,System.String,Microsoft.AspNetCore.Http.CookieOptions)">
            <inheritdoc cref="M:Microsoft.AspNetCore.Http.BasicCookieManager.AppendResponseCookieAsync(System.String,System.String,Microsoft.AspNetCore.Http.CookieOptions)" />
        </member>
        <member name="M:Microsoft.AspNetCore.Http.BasicCookieManager.DeleteCookieAsync(System.String,Microsoft.AspNetCore.Http.CookieOptions)">
            <summary>
            Delete a cookie.
            </summary>
            <param name="key">The key of the cookie.</param>
            <param name="options"><inheritdoc cref="T:Microsoft.AspNetCore.Http.CookieOptions"/></param>
        </member>
        <member name="M:Microsoft.AspNetCore.Http.BasicCookieManager.DeleteCookieAsync(Microsoft.JSInterop.IJSRuntime,System.String,Microsoft.AspNetCore.Http.CookieOptions)">
            <inheritdoc cref="M:Microsoft.AspNetCore.Http.BasicCookieManager.DeleteCookieAsync(System.String,Microsoft.AspNetCore.Http.CookieOptions)" />
        </member>
        <member name="M:Microsoft.AspNetCore.Http.BasicCookieManager.DeleteCookieAsync(Microsoft.AspNetCore.Http.HttpContext,System.String,Microsoft.AspNetCore.Http.CookieOptions)">
            <inheritdoc cref="M:Microsoft.AspNetCore.Http.BasicCookieManager.DeleteCookieAsync(System.String,Microsoft.AspNetCore.Http.CookieOptions)" />
        </member>
        <member name="M:Microsoft.AspNetCore.Http.BasicCookieManager.GetRequestCookieAsync(System.String,System.Boolean,Microsoft.AspNetCore.Http.CookieOptions)">
            <summary>
            Get a cookie.
            </summary>
            <param name="key">The key of the cookie.</param>
            <param name="allowNull">If false then will throw an exception when the value is null. The default should be false.</param>
            <param name="options"><inheritdoc cref="T:Microsoft.AspNetCore.Http.CookieOptions"/></param>
            <returns>The value of a cookie specified by </returns>
        </member>
        <member name="M:Microsoft.AspNetCore.Http.BasicCookieManager.GetRequestCookieAsync(Microsoft.JSInterop.IJSRuntime,System.String,System.Boolean,Microsoft.AspNetCore.Http.CookieOptions)">
            <inheritdoc cref="M:Microsoft.AspNetCore.Http.BasicCookieManager.GetRequestCookieAsync(System.String,System.Boolean,Microsoft.AspNetCore.Http.CookieOptions)" />
        </member>
        <member name="M:Microsoft.AspNetCore.Http.BasicCookieManager.GetRequestCookieAsync(Microsoft.AspNetCore.Http.HttpContext,System.String,System.Boolean,Microsoft.AspNetCore.Http.CookieOptions)">
            <inheritdoc cref="M:Microsoft.AspNetCore.Http.BasicCookieManager.GetRequestCookieAsync(System.String,System.Boolean,Microsoft.AspNetCore.Http.CookieOptions)" />
        </member>
        <member name="T:Microsoft.AspNetCore.Http.CookieFactory">
            <summary>
            A factory for creating individual cookies.
            </summary>
        </member>
        <member name="M:Microsoft.AspNetCore.Http.CookieFactory.#ctor(Microsoft.AspNetCore.Http.BasicCookieManager)">
            <summary>
            Constructor for cookie factory
            </summary>
            <param name="manager">BasicCookieManager</param>
        </member>
        <member name="M:Microsoft.AspNetCore.Http.CookieFactory.CreateCookie``1(System.String)">
            <summary>
            Create the cookie.
            </summary>
            <typeparam name="T">The <seealso cref="T:System.Type" /> the object is that is stored in the cookie. The <seealso cref="T:System.Text.Json.JsonSerializer" /> will be used to store and retrieve this value.</typeparam>
            <param name="cookieKey">The cookie key.</param>
            <returns>A basic cookie for getting, setting, and deleting cookie values.</returns>
        </member>
        <member name="T:Microsoft.AspNetCore.Http.NullCookieValueException">
            <summary>
            Exception throw when a cookie has a null value and it is not allowed.
            </summary>
        </member>
        <member name="P:Microsoft.AspNetCore.Http.NullCookieValueException.CookieKey">
            <summary>
            The cookie key that has the null value.
            </summary>
        </member>
        <member name="M:Microsoft.AspNetCore.Http.NullCookieValueException.#ctor(System.String)">
            <summary>
            Create a null cookie exception for the given <paramref name="cookieKey"/>
            </summary>
            <param name="cookieKey">The cookie key that has the null value.</param>
        </member>
        <member name="T:Microsoft.Extensions.DependencyInjection.DiscoverableBackgroundService`1">
            <summary>
            Special case of a <seealso cref="T:Microsoft.Extensions.DependencyInjection.DiscoverableService"/> and 
            <seealso cref="T:Microsoft.Extensions.Hosting.BackgroundService"/>. <inheritdoc /> 
            </summary>
            <typeparam name="T">A type that implments <seealso cref="T:Microsoft.Extensions.DependencyInjection.DiscoverableBackgroundService`1"/>.</typeparam>
        </member>
        <member name="M:Microsoft.Extensions.DependencyInjection.DiscoverableBackgroundService`1.ConfigureAsService(Microsoft.Extensions.DependencyInjection.IServiceCollection,Microsoft.Extensions.Configuration.IConfiguration)">
            <summary>
            <inheritdoc /> Base implementation just addes the <typeparamref name="T"/>
            as a hosted service to the services collection. Override to extend
            functionality.
            </summary>
            <param name="services"><inheritdoc /></param>
            <param name="configuration"><inheritdoc /></param>
        </member>
        <member name="M:Microsoft.Extensions.DependencyInjection.DiscoverableBackgroundService`1.InitializeAsync(System.Threading.CancellationToken)">
            <summary>
            This method is called once on startup. The return value should be if the 
            initialization was successful or not. If the return is true, then the 
            <seealso cref="M:Microsoft.Extensions.DependencyInjection.DiscoverableBackgroundService`1.ExecuteAsync(System.Threading.CancellationToken)"/> method is called. If the
            return is false, then it is not called.
            </summary>
            <param name="stoppingToken">Trigger when <seealso cref="M:Microsoft.Extensions.Hosting.IHostedService.StopAsync(System.Threading.CancellationToken)"/> is called.</param>
            <returns>Returns a Task of a long running operation. If the task completes with true, then the <seealso cref="M:Microsoft.Extensions.DependencyInjection.DiscoverableBackgroundService`1.ExecuteAsync(System.Threading.CancellationToken)"/> method is called. If the task completes with false, then it is not called.</returns>
        </member>
        <member name="M:Microsoft.Extensions.DependencyInjection.DiscoverableBackgroundService`1.ExecuteAsync(System.Threading.CancellationToken)">
            <inheritdoc cref="M:Microsoft.Extensions.Hosting.BackgroundService.ExecuteAsync(System.Threading.CancellationToken)"/>
        </member>
        <member name="M:Microsoft.Extensions.DependencyInjection.DiscoverableBackgroundService`1.StartAsync(System.Threading.CancellationToken)">
            <inheritdoc cref="M:Microsoft.Extensions.Hosting.BackgroundService.StartAsync(System.Threading.CancellationToken)"/>
        </member>
        <member name="M:Microsoft.Extensions.DependencyInjection.DiscoverableBackgroundService`1.StopAsync(System.Threading.CancellationToken)">
            <inheritdoc cref="M:Microsoft.Extensions.Hosting.BackgroundService.StopAsync(System.Threading.CancellationToken)"/>
        </member>
        <member name="M:Microsoft.Extensions.DependencyInjection.DiscoverableBackgroundService`1.Dispose">
            <inheritdoc cref="M:Microsoft.Extensions.Hosting.BackgroundService.Dispose"/>
        </member>
        <member name="T:Microsoft.Extensions.DependencyInjection.DiscoverableService">
            <summary>
            Abstract implimentation of the discoverable service. Overriding
            this class should be provided as a application service.
            </summary>
        </member>
        <member name="P:Microsoft.Extensions.DependencyInjection.DiscoverableService.Order">
            <inheritdoc cref="P:Microsoft.Extensions.DependencyInjection.IDiscoverable.Order" />
        </member>
        <member name="M:Microsoft.Extensions.DependencyInjection.DiscoverableService.ConfigureAsService(Microsoft.Extensions.DependencyInjection.IServiceCollection,Microsoft.Extensions.Configuration.IConfiguration)">
            <inheritdoc cref="M:Microsoft.Extensions.DependencyInjection.IDiscoverable.ConfigureAsService(Microsoft.Extensions.DependencyInjection.IServiceCollection,Microsoft.Extensions.Configuration.IConfiguration)" />
        </member>
        <member name="T:Microsoft.Extensions.DependencyInjection.DiscoverableServicesExtensions">
            <summary>
            Extension method for discovering all services and registering them 
            with the dependency injection system.
            </summary>
        </member>
        <member name="M:Microsoft.Extensions.DependencyInjection.DiscoverableServicesExtensions.AddDiscoverableServices(Microsoft.Extensions.DependencyInjection.IServiceCollection,Microsoft.Extensions.Configuration.IConfiguration,System.Boolean)">
            <summary>
            Discovering all services and registering them with the 
            dependency injection services collection. This method will
            try to find all references classes implmenting interface
            <seealso cref="T:Microsoft.Extensions.DependencyInjection.IDiscoverable"/>.
            </summary>
            <param name="services">The service collection used for registering application dependencies.</param>
            <param name="configuration">The application configuration.</param>
            <param name="excludeLibraryAssemblies">Only include the current assembly for searching.</param>
            <returns>For chainging calls to the services collection, it is returned.</returns>
        </member>
        <member name="M:Microsoft.Extensions.DependencyInjection.DiscoverableServicesExtensions.AddDiscoverableServices(Microsoft.Extensions.DependencyInjection.IServiceCollection,Microsoft.Extensions.Configuration.IConfiguration,System.Reflection.Assembly[])">
            <inheritdoc cref="M:Microsoft.Extensions.DependencyInjection.DiscoverableServicesExtensions.AddDiscoverableServices(Microsoft.Extensions.DependencyInjection.IServiceCollection,Microsoft.Extensions.Configuration.IConfiguration,System.Boolean,System.Reflection.Assembly[])"/>
        </member>
        <member name="M:Microsoft.Extensions.DependencyInjection.DiscoverableServicesExtensions.AddDiscoverableServices(Microsoft.Extensions.DependencyInjection.IServiceCollection,Microsoft.Extensions.Configuration.IConfiguration,System.Boolean,System.Reflection.Assembly[])">
            <summary>
            Discovering all services and registering them with the 
            dependency injection services collection.
            </summary>
            <param name="services">The service collection used for registering application dependencies.</param>
            <param name="assembliesToSearch">List assembly that should be searched for references to classes implementing the interface <seealso cref="T:Microsoft.Extensions.DependencyInjection.IDiscoverable"/>.</param>
            <param name="configuration">The application configuration.</param>
            <param name="excludeLibraryAssemblies">Only include the provided assemblies for searching.</param>	/// <returns>For chainging calls to the services collection, it is returned.</returns>
        </member>
        <member name="M:Microsoft.Extensions.DependencyInjection.DiscoverableServicesExtensions.AddDiscoverableService``1(Microsoft.Extensions.DependencyInjection.IServiceCollection,Microsoft.Extensions.Configuration.IConfiguration)">
            <summary>
            Register the type as a service using its registration method defined by
            the interface <seealso cref="T:Microsoft.Extensions.DependencyInjection.IDiscoverable"/>.
            </summary>
            <typeparam name="TDiscoverableService">The object type that should be registerd with the dependency injection services collection.</typeparam>
            <param name="services">The service collection used for registering application dependencies.</param>
            <param name="configuration">The application configuration.</param>
            <returns>For chainging calls to the services collection, it is returned.</returns>
        </member>
        <member name="T:Microsoft.Extensions.DependencyInjection.DiscoverableSingletonService`1">
            <inheritdoc cref="T:Microsoft.Extensions.DependencyInjection.DiscoverableSingletonService`2" />
        </member>
        <member name="T:Microsoft.Extensions.DependencyInjection.DiscoverableSingletonService`2">
            <summary>/// 
            Abstract implimentation of the discoverable service. Overriding
            this class should be provided as a application service. This implements
            adding the parent class as a singleton in the DI before calling additional
            logic.
            </summary>
            <typeparam name="TService">The type of the service to register.</typeparam>
            <typeparam name="TImplementation">The type of the implementation to use.</typeparam>
        </member>
        <member name="P:Microsoft.Extensions.DependencyInjection.DiscoverableSingletonService`2.IsLoaded">
            <summary>
            Used to keep from loading the service more then once.
            </summary>
        </member>
        <member name="M:Microsoft.Extensions.DependencyInjection.DiscoverableSingletonService`2.ConfigureAsSingletonService(Microsoft.Extensions.DependencyInjection.IServiceCollection,Microsoft.Extensions.Configuration.IConfiguration)">
            <summary>
            <inheritdoc cref="M:Microsoft.Extensions.DependencyInjection.IDiscoverable.ConfigureAsService(Microsoft.Extensions.DependencyInjection.IServiceCollection,Microsoft.Extensions.Configuration.IConfiguration)" />
            The parent class will be added as a singleton to the DI before calling this method.
            </summary>
            <param name="services"><inheritdoc cref="M:Microsoft.Extensions.DependencyInjection.IDiscoverable.ConfigureAsService(Microsoft.Extensions.DependencyInjection.IServiceCollection,Microsoft.Extensions.Configuration.IConfiguration)" /></param>
            <param name="configuration"><inheritdoc cref="M:Microsoft.Extensions.DependencyInjection.IDiscoverable.ConfigureAsService(Microsoft.Extensions.DependencyInjection.IServiceCollection,Microsoft.Extensions.Configuration.IConfiguration)" /></param>
        </member>
        <member name="M:Microsoft.Extensions.DependencyInjection.DiscoverableSingletonService`2.ConfigureAsService(Microsoft.Extensions.DependencyInjection.IServiceCollection,Microsoft.Extensions.Configuration.IConfiguration)">
            <inheritdoc cref="M:Microsoft.Extensions.DependencyInjection.IDiscoverable.ConfigureAsService(Microsoft.Extensions.DependencyInjection.IServiceCollection,Microsoft.Extensions.Configuration.IConfiguration)" />
        </member>
        <member name="T:Microsoft.Extensions.DependencyInjection.IDiscoverable">
            <summary>
            Override this interface to implement the order and add a configure services
            method for adding DI components.
            </summary>
        </member>
        <member name="P:Microsoft.Extensions.DependencyInjection.IDiscoverable.Order">
            <summary>
            The order in which the service should be registered. Lower order 
            numbers will be registered before higher order numbers. Orders can be 
            negative. Zero is the default order and order of registration is not
            garenteed if the order matches another services order number.
            </summary>
        </member>
        <member name="M:Microsoft.Extensions.DependencyInjection.IDiscoverable.ConfigureAsService(Microsoft.Extensions.DependencyInjection.IServiceCollection,Microsoft.Extensions.Configuration.IConfiguration)">
            <summary>
            Method called on the object to run the objects registration with
            the dependency injection system.
            </summary>
            <param name="services">The service collection used for registering application dependencies.</param>
            <param name="configuration">The application configuration.</param>
        </member>
        <member name="T:Microsoft.Extensions.DependencyInjection.HttpContextExtensions">
            <summary>
            Add <seealso cref="T:Microsoft.AspNetCore.Http.IHttpContextAccessor"/> and
            <seealso cref="T:Microsoft.AspNetCore.Http.HttpContext"/> to dependency injection.
            </summary>
        </member>
        <member name="M:Microsoft.Extensions.DependencyInjection.HttpContextExtensions.AddHttpContext(Microsoft.Extensions.DependencyInjection.IServiceCollection)">
            <summary>
            <inheritdoc cref="T:Microsoft.Extensions.DependencyInjection.HttpContextExtensions"/>
            </summary>
            <param name="services"><seealso cref="T:Microsoft.Extensions.DependencyInjection.IServiceCollection"/></param>
            <returns><seealso cref="T:Microsoft.Extensions.DependencyInjection.IServiceCollection"/></returns>
            <exception cref="T:System.NullReferenceException"></exception>
        </member>
        <member name="T:Microsoft.Extensions.DependencyInjection.DiscoverableTask`2">
            <summary>
            <inheritdoc /> This task is for configuring and setting scheduled 
            events.
            </summary>
            <typeparam name="TTask">A type that implements <seealso cref="T:Microsoft.Extensions.DependencyInjection.DiscoverableTask`2" />.</typeparam>
            <typeparam name="TSchedule">A type that implements <seealso cref="T:Microsoft.Extensions.Hosting.DiscoverableTaskSchedule"/>.</typeparam>
        </member>
        <member name="T:Microsoft.Extensions.DependencyInjection.DiscoverableTask`2.Response">
            <summary>
            Response from the <seealso cref="M:Microsoft.Extensions.DependencyInjection.DiscoverableTask`2.RepeatTaskAsync(System.Threading.CancellationToken)"/>.
            Use the static helper methods <seealso cref="M:Microsoft.Extensions.DependencyInjection.DiscoverableTask`2.Response.Success(System.String)"/>,
            <seealso cref="M:Microsoft.Extensions.Diagnostics.HealthChecks.BasicHealthCheck.FailureState(System.Exception,System.Collections.Generic.IReadOnlyDictionary{System.String,System.Object})"/>, 
            and <seealso cref="M:Microsoft.Extensions.DependencyInjection.DiscoverableTask`2.Response.Critical(System.Exception)"/> for ideal return values for this class record.<br />
            <br/>
            <seealso cref="M:Microsoft.Extensions.DependencyInjection.DiscoverableTask`2.Response.Success(System.String)"/> -- Returns 
            </summary>
            <param name="IsSuccessful">Did the <seealso cref="M:Microsoft.Extensions.DependencyInjection.DiscoverableTask`2.RepeatTaskAsync(System.Threading.CancellationToken)"/> complete successfully. Note the task could have failed, but still completed. Use <seealso cref="M:Microsoft.Extensions.DependencyInjection.DiscoverableTask`2.Response.Success(System.String)"/></param>
            <param name="ShouldUpdate"></param>
            <param name="Message"></param>
            <param name="Exception"></param>
        </member>
        <member name="M:Microsoft.Extensions.DependencyInjection.DiscoverableTask`2.Response.#ctor(System.Boolean,System.Boolean,System.String,System.Exception)">
            <summary>
            Response from the <seealso cref="M:Microsoft.Extensions.DependencyInjection.DiscoverableTask`2.RepeatTaskAsync(System.Threading.CancellationToken)"/>.
            Use the static helper methods <seealso cref="M:Microsoft.Extensions.DependencyInjection.DiscoverableTask`2.Response.Success(System.String)"/>,
            <seealso cref="M:Microsoft.Extensions.Diagnostics.HealthChecks.BasicHealthCheck.FailureState(System.Exception,System.Collections.Generic.IReadOnlyDictionary{System.String,System.Object})"/>, 
            and <seealso cref="M:Microsoft.Extensions.DependencyInjection.DiscoverableTask`2.Response.Critical(System.Exception)"/> for ideal return values for this class record.<br />
            <br/>
            <seealso cref="M:Microsoft.Extensions.DependencyInjection.DiscoverableTask`2.Response.Success(System.String)"/> -- Returns 
            </summary>
            <param name="IsSuccessful">Did the <seealso cref="M:Microsoft.Extensions.DependencyInjection.DiscoverableTask`2.RepeatTaskAsync(System.Threading.CancellationToken)"/> complete successfully. Note the task could have failed, but still completed. Use <seealso cref="M:Microsoft.Extensions.DependencyInjection.DiscoverableTask`2.Response.Success(System.String)"/></param>
            <param name="ShouldUpdate"></param>
            <param name="Message"></param>
            <param name="Exception"></param>
        </member>
        <member name="P:Microsoft.Extensions.DependencyInjection.DiscoverableTask`2.Response.IsSuccessful">
            <summary>Did the <seealso cref="M:Microsoft.Extensions.DependencyInjection.DiscoverableTask`2.RepeatTaskAsync(System.Threading.CancellationToken)"/> complete successfully. Note the task could have failed, but still completed. Use <seealso cref="M:Microsoft.Extensions.DependencyInjection.DiscoverableTask`2.Response.Success(System.String)"/></summary>
        </member>
        <member name="P:Microsoft.Extensions.DependencyInjection.DiscoverableTask`2.Response.ShouldUpdate">
            <summary></summary>
        </member>
        <member name="P:Microsoft.Extensions.DependencyInjection.DiscoverableTask`2.Response.Message">
            <summary></summary>
        </member>
        <member name="P:Microsoft.Extensions.DependencyInjection.DiscoverableTask`2.Response.Exception">
            <summary></summary>
        </member>
        <member name="M:Microsoft.Extensions.DependencyInjection.DiscoverableTask`2.Response.Success(System.String)">
            <summary>
            Create and return a success response.
            </summary>
            <param name="message">Optional message to be returned.</param>
            <returns>Successful response object.</returns>
        </member>
        <member name="M:Microsoft.Extensions.DependencyInjection.DiscoverableTask`2.Response.Failure(System.String)">
            <summary>
            Create and return a failure response. Used to handle basic
            errors. If an exception is thrown, then 
            <seealso cref="M:Microsoft.Extensions.DependencyInjection.DiscoverableTask`2.Response.Critical(System.Exception)"/> should be called.
            </summary>
            <param name="message">The failure message.</param>
            <returns>Failure response with message.</returns>
        </member>
        <member name="M:Microsoft.Extensions.DependencyInjection.DiscoverableTask`2.Response.Critical(System.Exception)">
            <summary>
            Create and return a critical response. Used to signify that
            the failure was catastrophic. If the issue is a recoverable or 
            able to be ignored, then consider returning a 
            <seealso cref="M:Microsoft.Extensions.DependencyInjection.DiscoverableTask`2.Response.Failure(System.String)"/>.
            </summary>
            <param name="exception"></param>
            <returns>Critical reseponse with associated exception.</returns>
        </member>
        <member name="P:Microsoft.Extensions.DependencyInjection.DiscoverableTask`2.Tag">
            <summary>
            Used for debuging and tagging the error messages.
            </summary>
        </member>
        <member name="P:Microsoft.Extensions.DependencyInjection.DiscoverableTask`2.LastRun">
            <summary>
            The date and time of the last run.
            </summary>
        </member>
        <member name="P:Microsoft.Extensions.DependencyInjection.DiscoverableTask`2.TaskSchedule">
            <summary>
            The schedule and frequency the <seealso cref="M:Microsoft.Extensions.DependencyInjection.DiscoverableTask`2.RepeatTaskAsync(System.Threading.CancellationToken)" />
            method should be triggered.
            </summary>
        </member>
        <member name="M:Microsoft.Extensions.DependencyInjection.DiscoverableTask`2.InitializeLastRunAsync(System.Threading.CancellationToken)">
            <summary>
            The default value of the last run or initial value.
            </summary>
            <param name="stoppingToken"><inheritdoc cref="T:System.Threading.CancellationToken" /></param>
            <returns>The last run datetime.</returns>
        </member>
        <member name="M:Microsoft.Extensions.DependencyInjection.DiscoverableTask`2.InitializeTaskScheduleAsync(System.Threading.CancellationToken)">
            <summary>
            The default or initial task schedule.
            </summary>
            <param name="stoppingToken"><inheritdoc cref="T:System.Threading.CancellationToken" /></param>
            <returns>The initial task schedule used for setting up the task.</returns>
        </member>
        <member name="M:Microsoft.Extensions.DependencyInjection.DiscoverableTask`2.#ctor(System.Int32)">
            <summary>
            A discoverable task that can be scheduled.
            </summary>
            <param name="maxThrottleInMinutes">The when a task is failing, what is the maximum time to wait between trys.</param>
        </member>
        <member name="M:Microsoft.Extensions.DependencyInjection.DiscoverableTask`2.RepeatTaskAsync(System.Threading.CancellationToken)">
            <summary>
            If <seealso cref="M:Microsoft.Extensions.DependencyInjection.DiscoverableBackgroundService`1.InitializeAsync(System.Threading.CancellationToken)" /> 
            returns true, then this method is called repeated by 
            <inheritdoc cref="M:Microsoft.Extensions.DependencyInjection.DiscoverableBackgroundService`1.ExecuteAsync(System.Threading.CancellationToken)" />
            </summary>
            <param name="stoppingToken"><inheritdoc cref="T:System.Threading.CancellationToken" /></param>
            <returns>If the execution was successful or not. If false, then the throttle is increased and the last run is not updated. If true, then the throttle is reset and the last run is updated with the current datetime.</returns>
        </member>
        <member name="M:Microsoft.Extensions.DependencyInjection.DiscoverableTask`2.StartAsync(System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Extensions.DependencyInjection.DiscoverableTask`2.ExecuteAsync(System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Extensions.DependencyInjection.DiscoverableTask`2.StopAsync(System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Extensions.DependencyInjection.DiscoverableTask`2.UpdateLastRunAsync(System.Threading.CancellationToken)">
            <summary>
            Override this method to be notified when the last run date has been 
            updated.
            </summary>
            <param name="stoppingToken"><inheritdoc cref="T:System.Threading.CancellationToken" /></param>
            <returns>An asynchronous task operation.</returns>
        </member>
        <member name="M:Microsoft.Extensions.DependencyInjection.DiscoverableTask`2.TaskCompletedAsync(System.String,System.Threading.CancellationToken)">
            <summary>
            Override this method to be notified when a task completes successfully.
            </summary>
            <param name="message">The message returned doing the task execution.</param>
            <param name="stoppingToken"><inheritdoc cref="T:System.Threading.CancellationToken" /></param>
            <returns>An asynchronous task operation.</returns>
        </member>
        <member name="M:Microsoft.Extensions.DependencyInjection.DiscoverableTask`2.TaskFailedAsync(System.Exception,System.Threading.CancellationToken)">
            <summary>
            Override this method to be notified when a task fails to complete 
            successfully.
            </summary>
            <param name="exception">The exception thrown during task execution.</param>
            <param name="stoppingToken"><inheritdoc cref="T:System.Threading.CancellationToken" /></param>
            <returns>An asynchronous task operation.</returns>
        </member>
        <member name="M:Microsoft.Extensions.DependencyInjection.DiscoverableTask`2.ElapsedMillisecondsLastRun">
            <summary>
            Get the elapsed millisconds from the last time the stopwatch was stopped.
            </summary>
            <returns>The total time the stopwatch ran for the last time it was stopped.</returns>
        </member>
        <member name="M:Microsoft.Extensions.DependencyInjection.DiscoverableTask`2.StopTiming">
            <summary>
            Stop the task timer so the ellapsed time can be retrieved for how long in seconds the task took to complete.
            </summary>
            <returns>The total time the stopwatch ran for, either by stopping the clock or what the value was the last time it was stopped.</returns>
        </member>
        <member name="M:Microsoft.Extensions.DependencyInjection.DiscoverableTask`2.StartTiming">
            <summary>
            Start the task timer so the time ellapsed to run the process can be recorded.
            </summary>
        </member>
        <member name="M:Microsoft.Extensions.DependencyInjection.DiscoverableTask`2.Dispose">
            <inheritdoc/>
        </member>
        <member name="T:Microsoft.Extensions.Diagnostics.HealthChecks.BasicHealthCheck">
            <summary>
            Base logic used for auto discovered health checks.
            <inheritdoc cref="T:Microsoft.Extensions.Diagnostics.HealthChecks.IHealthCheck"/>
            </summary>
        </member>
        <member name="P:Microsoft.Extensions.Diagnostics.HealthChecks.BasicHealthCheck.FailureStatus">
            <summary>
            The status used for the failure state. The default is
            <seealso cref="F:Microsoft.Extensions.Diagnostics.HealthChecks.HealthStatus.Unhealthy"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Extensions.Diagnostics.HealthChecks.BasicHealthCheck.FailureState(System.String,System.Collections.Generic.IReadOnlyDictionary{System.String,System.Object})">
            <summary>
            Returns a failure state using the <paramref name="description"/> 
            of the failure and optional <paramref name="data"/>.
            </summary>
            <param name="description">A discription of the failure and how to resolve the failure.</param>
            <param name="data">Additional details used in diagnosing the failure.</param>
            <returns>Returns a failure state <seealso cref="T:Microsoft.Extensions.Diagnostics.HealthChecks.HealthCheckResult"/>.</returns>
        </member>
        <member name="M:Microsoft.Extensions.Diagnostics.HealthChecks.BasicHealthCheck.FailureState(System.Exception,System.Collections.Generic.IReadOnlyDictionary{System.String,System.Object})">
            <summary>
            Returns a failure state using the <paramref name="exception"/> 
            of the failure and optional <paramref name="data"/>.
            </summary>
            <param name="exception">The exception that was thrown during the health check.</param>
            <param name="data">Additional details used in diagnosing the failure.</param>
            <returns>Returns a failure state <seealso cref="T:Microsoft.Extensions.Diagnostics.HealthChecks.HealthCheckResult"/>.</returns>
        </member>
        <member name="P:Microsoft.Extensions.Diagnostics.HealthChecks.BasicHealthCheck.Name">
            <summary>
            The name of the health check.
            </summary>
        </member>
        <member name="P:Microsoft.Extensions.Diagnostics.HealthChecks.BasicHealthCheck.Tags">
            <summary>
            A list of tags that can be used to filter health checks.
            </summary>
        </member>
        <member name="P:Microsoft.Extensions.Diagnostics.HealthChecks.BasicHealthCheck.Timeout">
            <summary>
            A <seealso cref="T:System.TimeSpan"/> representing the timeout 
            of the check. The default is 2 minutes.
            </summary>
        </member>
        <member name="M:Microsoft.Extensions.Diagnostics.HealthChecks.BasicHealthCheck.#ctor">
            <summary>
            Basic health check without <seealso cref="P:Microsoft.Extensions.Diagnostics.HealthChecks.BasicHealthCheck.Name"/> and
            <seealso cref="P:Microsoft.Extensions.Diagnostics.HealthChecks.BasicHealthCheck.Tags"/>. The <seealso cref="P:Microsoft.Extensions.Diagnostics.HealthChecks.BasicHealthCheck.Name"/> will be 
            set automatically using the class type and formatted with 
            <seealso cref="M:System.Text.StringExtensions.ToTitleCase(System.String,System.Boolean)"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Extensions.Diagnostics.HealthChecks.BasicHealthCheck.#ctor(System.String[])">
            <summary>
            Basic health check without <seealso cref="P:Microsoft.Extensions.Diagnostics.HealthChecks.BasicHealthCheck.Name"/> and optional
            <seealso cref="P:Microsoft.Extensions.Diagnostics.HealthChecks.BasicHealthCheck.Tags"/>. The <seealso cref="P:Microsoft.Extensions.Diagnostics.HealthChecks.BasicHealthCheck.Name"/> will be 
            set automatically using the class type and formatted with 
            <seealso cref="M:System.Text.StringExtensions.ToTitleCase(System.String,System.Boolean)"/>.
            </summary>
            <param name="tags">A list of tags that can be used to filter health checks.</param>
        </member>
        <member name="M:Microsoft.Extensions.Diagnostics.HealthChecks.BasicHealthCheck.#ctor(System.String,System.String[])">
            <summary>
            Basic health check with <seealso cref="P:Microsoft.Extensions.Diagnostics.HealthChecks.BasicHealthCheck.Name"/> and optional
            <seealso cref="P:Microsoft.Extensions.Diagnostics.HealthChecks.BasicHealthCheck.Tags"/>.
            </summary>
            <param name="name">The name of the health check.</param>
            <param name="tags">A list of tags that can be used to filter health checks.</param>
        </member>
        <member name="M:Microsoft.Extensions.Diagnostics.HealthChecks.BasicHealthCheck.CheckHealthAsync(Microsoft.Extensions.Diagnostics.HealthChecks.HealthCheckContext,System.Object,System.Threading.CancellationToken)">
            <inheritdoc cref="M:Microsoft.Extensions.Diagnostics.HealthChecks.IHealthCheck.CheckHealthAsync(Microsoft.Extensions.Diagnostics.HealthChecks.HealthCheckContext,System.Threading.CancellationToken)"/>
        </member>
        <member name="M:Microsoft.Extensions.Diagnostics.HealthChecks.BasicHealthCheck.CheckHealthAsync(Microsoft.Extensions.Diagnostics.HealthChecks.HealthCheckContext,System.Threading.CancellationToken)">
            <inheritdoc cref="M:Microsoft.Extensions.Diagnostics.HealthChecks.IHealthCheck.CheckHealthAsync(Microsoft.Extensions.Diagnostics.HealthChecks.HealthCheckContext,System.Threading.CancellationToken)"/>
        </member>
        <member name="T:Microsoft.Extensions.Hosting.DiscoverableTaskSchedule">
            <summary>
            A schedule for when a task should be trigger.
            </summary>
        </member>
        <member name="P:Microsoft.Extensions.Hosting.DiscoverableTaskSchedule.Identification">
            <summary>
            Task ID for use 
            </summary>
        </member>
        <member name="P:Microsoft.Extensions.Hosting.DiscoverableTaskSchedule.Type">
            <summary>
            The schedule type for this task schedule.
            </summary>
        </member>
        <member name="M:Microsoft.Extensions.Hosting.DiscoverableTaskSchedule.DaysOfTheWeek">
            <summary>
            The days of the week this task should be run 
            on if applicable.
            </summary>
        </member>
        <member name="P:Microsoft.Extensions.Hosting.DiscoverableTaskSchedule.Time">
            <summary>
            The time of day or frequency a task should run.
            </summary>
        </member>
        <member name="M:Microsoft.Extensions.Hosting.DiscoverableTaskSchedule.#ctor(Microsoft.Extensions.Hosting.DiscoverableTaskScheduleType,System.TimeSpan)">
            <summary>
            Create a task schedule. Not all parameters are used or needed or
            interpreted the same, use with caution.
            </summary>
            <param name="type">The type of schedule.</param>
            <param name="time">The time for frequency of triggers.</param>
        </member>
        <member name="M:Microsoft.Extensions.Hosting.DiscoverableTaskSchedule.DelayUntilNextEventAsync(System.DateTime,System.Threading.CancellationToken)">
            <summary>
            Delay the processing until the next time a task should be run.
            </summary>
            <param name="lastRun">The date and time of the last run.</param>
            <param name="stoppingToken">A token handling cancelling the task if it should be stopped early.</param>
            <returns>An awaitable delay task.</returns>
        </member>
        <member name="M:Microsoft.Extensions.Hosting.DiscoverableTaskSchedule.NextScheduledTime(System.DateTime)">
            <summary>
            Get the next date and time for when the scheduled task should be run given a previous run time.
            </summary>
            <param name="lastRun">The date and time of the last run.</param>
            <returns>The date and time of the next run.</returns>
        </member>
        <member name="M:Microsoft.Extensions.Hosting.DiscoverableTaskSchedule.CreateDisabledTask">
            <summary>
            Create a task schedule that is disabled.
            </summary>
            <returns>A disabled task schedule.</returns>
        </member>
        <member name="M:Microsoft.Extensions.Hosting.DiscoverableTaskSchedule.CreateContinuousTask">
            <summary>
            Create a task that runs again immediately after previous run finishes.
            </summary>
            <returns>A task schedule configured to run continuously.</returns>
        </member>
        <member name="M:Microsoft.Extensions.Hosting.DiscoverableTaskSchedule.CreateFrequencyTask(System.Int32)">
            <summary>
            Create a task that runs every x number of <paramref name="minutes"/>.
            </summary>
            <param name="minutes">The time between each run of the task.</param>
            <returns>A task schedule configured for a frequency type.</returns>
        </member>
        <member name="M:Microsoft.Extensions.Hosting.DiscoverableTaskSchedule.CreateHourlyTask(System.Int32)">
            <summary>
            Create a task that runs every hour on the <paramref name="minute"/> mark.
            </summary>
            <param name="minute">The minute mark of the hour the task should run.</param>
            <returns>A task schedule configured for a hourly task type.</returns>
        </member>
        <member name="M:Microsoft.Extensions.Hosting.DiscoverableTaskSchedule.CreateDaily(System.Int32,System.Int32)">
            <summary>
            Create a task that runs every day on the <paramref name="hour"/> and
            <paramref name="minute"/>.
            </summary>
            <param name="hour">The hour the task should run each day.</param>
            <param name="minute">The minute of the hour that the task should run each day.</param>
            <returns>A task schedule configured for a daily running task.</returns>
        </member>
        <member name="M:Microsoft.Extensions.Hosting.DiscoverableTaskSchedule.CreateWeekly(System.Int32,System.Int32,System.DayOfWeek[])">
            <summary>
            Create a task that runs for each <paramref name="daysOfTheWeek"/> at
            the specific <paramref name="hour"/> and <paramref name="minute"/>.
            </summary>
            <param name="hour">The hour the task should run each <paramref name="daysOfTheWeek"/>.</param>
            <param name="minute">The minute of the hour that the task should run each <paramref name="daysOfTheWeek"/>.</param>
            <param name="daysOfTheWeek">The days of the week the task should run on.</param>
            <returns>A task schedule configured for a weekly running task.</returns>
        </member>
        <member name="M:Microsoft.Extensions.Hosting.DiscoverableTaskSchedule.CreateMonthly(System.Int32,System.Int32,System.Int32)">
            <summary>
            Create a task that runs each month on the <paramref name="day"/> of the
            month at the specific <paramref name="hour"/> and <paramref name="minute"/>.
            </summary>
            <param name="day">The day of the month to run the task.</param>
            <param name="hour">The hour of the day to run the task.</param>
            <param name="minute">The minute of the hour to run the task.</param>
            <returns>A task schedule configured for a monthly running task.</returns>
        </member>
        <member name="T:Microsoft.Extensions.Hosting.DiscoverableTaskScheduleID">
            <summary>
            Get and set a task id.
            </summary>
        </member>
        <member name="M:Microsoft.Extensions.Hosting.DiscoverableTaskScheduleID.SetTaskID(System.String)">
            <summary>
            Set the task id as a string.
            </summary>
            <param name="identifier"><inheritdoc cref="M:Microsoft.Extensions.Hosting.DiscoverableTaskScheduleID.SetTaskID``1(``0)" /></param>
        </member>
        <member name="M:Microsoft.Extensions.Hosting.DiscoverableTaskScheduleID.SetTaskID(System.Int32)">
            <summary>
            Set the task id as an integer.
            </summary>
            <param name="id"><inheritdoc cref="M:Microsoft.Extensions.Hosting.DiscoverableTaskScheduleID.SetTaskID``1(``0)"/></param>
        </member>
        <member name="M:Microsoft.Extensions.Hosting.DiscoverableTaskScheduleID.SetTaskID(System.Guid)">
            <summary>
            Set the task id as an guid.
            </summary>
            <param name="guid"><inheritdoc cref="M:Microsoft.Extensions.Hosting.DiscoverableTaskScheduleID.SetTaskID``1(``0)"/></param>
        </member>
        <member name="M:Microsoft.Extensions.Hosting.DiscoverableTaskScheduleID.SetTaskID``1(``0)">
            <summary>
            Set the Task ID to a custom type.
            </summary>
            <typeparam name="T">The user defined type for use as a task id handler.</typeparam>
            <param name="taskID">The identifier of the task.</param>
        </member>
        <member name="M:Microsoft.Extensions.Hosting.DiscoverableTaskScheduleID.GetTaskID``1">
            <summary>
            Get the task id.
            </summary>
            <typeparam name="T">The type of the ID.</typeparam>
            <returns>The value of the task id.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if the task id has not been set.</exception>
            <exception cref="T:System.InvalidCastException">Thrown if trying to get the task id as a different type then when it was set.</exception>
        </member>
        <member name="M:Microsoft.Extensions.Hosting.DiscoverableTaskScheduleID.GetStringTaskID">
            <summary>
            Get the task id as a string.
            </summary>
            <returns>The string task id.</returns>
        </member>
        <member name="M:Microsoft.Extensions.Hosting.DiscoverableTaskScheduleID.GetIntTaskID">
            <summary>
            Get the task id as an integer.
            </summary>
            <returns>The integer task id.</returns>
        </member>
        <member name="M:Microsoft.Extensions.Hosting.DiscoverableTaskScheduleID.GetGuidTaskID">
            <summary>
            Get the task id as a guid.
            </summary>
            <returns>The guid task id.</returns>
        </member>
        <member name="T:Microsoft.Extensions.Hosting.DiscoverableTaskScheduleType">
            <summary>
            How frequently should a task be run.
            </summary>
        </member>
        <member name="F:Microsoft.Extensions.Hosting.DiscoverableTaskScheduleType.Disabled">
            <summary>
            Schedule is ignored.
            </summary>
        </member>
        <member name="F:Microsoft.Extensions.Hosting.DiscoverableTaskScheduleType.Continuously">
            <summary>
            As soon as the process is complete,
            trigger the process again.
            </summary>
        </member>
        <member name="F:Microsoft.Extensions.Hosting.DiscoverableTaskScheduleType.Frequency">
            <summary>
            As soon as the process is complete,
            wait for frequency to be met before
            triggering the process again.
            </summary>
        </member>
        <member name="F:Microsoft.Extensions.Hosting.DiscoverableTaskScheduleType.Hourly">
            <summary>
            Run every day on an hourly bases 
            at a specific time during the hour.
            </summary>
        </member>
        <member name="F:Microsoft.Extensions.Hosting.DiscoverableTaskScheduleType.Daily">
            <summary>
            Run every day at a specific time 
            of day.
            </summary>
        </member>
        <member name="F:Microsoft.Extensions.Hosting.DiscoverableTaskScheduleType.Weekly">
            <summary>
            Run every day at a specific time
            on specific days.
            </summary>
        </member>
        <member name="F:Microsoft.Extensions.Hosting.DiscoverableTaskScheduleType.Monthly">
            <summary>
            Run once a month at a specific
            day and time.
            </summary>
        </member>
        <member name="T:Microsoft.JSInterop.SessionStorageFactoryService">
            <summary>
            Factory for creating session storage services. Use this to create
            an object to get and set data reliably with session storage.
            </summary>
        </member>
        <member name="M:Microsoft.JSInterop.SessionStorageFactoryService.#ctor(Microsoft.JSInterop.IJSRuntime)">
            <summary>
            Create a service factory getting 
            </summary>
            <param name="runtime"></param>
        </member>
        <member name="M:Microsoft.JSInterop.SessionStorageFactoryService.Create``1(System.String)">
            <summary>
            Create a session storage state for the supplied <paramref name="key"/>.
            </summary>
            <typeparam name="T">Data type of the data stored in </typeparam>
            <param name="key">The key value for storing session data.</param>
            <returns>A session storage state object for the given <paramref name="key"/>.</returns>
        </member>
        <member name="M:Microsoft.JSInterop.SessionStorageFactoryService.GetAsync``1(System.String,System.Threading.CancellationToken)">
            <summary>
            Get data from session storage using <paramref name="key"/>
            with the JSON.parse(data).
            </summary>
            <typeparam name="T">The type of the data to be saved to session storage.</typeparam>
            <param name="key">The key value for storing session data.</param>
            <param name="cancellationToken"><inheritdoc cref="T:System.Threading.CancellationToken"/></param>
            <returns>A task representing the status of the request to delete a session storage data.</returns>
        </member>
        <member name="M:Microsoft.JSInterop.SessionStorageFactoryService.GetAsync``1(System.String,``0,System.Threading.CancellationToken)">
            <summary>
            Get data from session storage using <paramref name="key"/> 
            with the JSON.parse(data ?? <paramref name="defaultValue"/>).
            </summary>
            <typeparam name="T">The type of the data to be saved to session storage.</typeparam>
            <param name="key">The key value for storing session data.</param>
            <param name="defaultValue">A default value to return if nothing stored in session storage.</param>
            <param name="cancellationToken"><inheritdoc cref="T:System.Threading.CancellationToken"/></param>
            <returns>A task representing the status of the request to add or update session storage data.</returns>
        </member>
        <member name="M:Microsoft.JSInterop.SessionStorageFactoryService.SetAsync``1(System.String,``0,System.Threading.CancellationToken)">
            <summary>
            Set or update data in session storage using <paramref name="key"/> 
            with the JSON.stringify(<paramref name="data"/>).
            </summary>
            <typeparam name="T">The type of the data to be saved to session storage.</typeparam>
            <param name="key">The key value for storing session data.</param>
            <param name="data">The object of data to be stored. This data will be JSON.stringify(<paramref name="data"/>).</param>
            <param name="cancellationToken"><inheritdoc cref="T:System.Threading.CancellationToken"/></param>
            <returns>A task representing the status of the request to add or update session storage data.</returns>
        </member>
        <member name="M:Microsoft.JSInterop.SessionStorageFactoryService.DeleteAsync(System.String,System.Threading.CancellationToken)">
            <summary>
            Delete pair from session storage using <paramref name="key"/>.
            </summary>
            <param name="key">The key value for storing session data.</param>
            <param name="cancellationToken"><inheritdoc cref="T:System.Threading.CancellationToken"/></param>
            <returns>A task representing the status of the request to delete a session storage data.</returns>
        </member>
        <member name="M:Microsoft.JSInterop.SessionStorageFactoryService.ConfigureAsService(Microsoft.Extensions.DependencyInjection.IServiceCollection,Microsoft.Extensions.Configuration.IConfiguration)">
            <inheritdoc/>
        </member>
        <member name="T:Microsoft.JSInterop.SessionStorageState`1">
            <summary>
            Session storage stage object for managing gettin, adding, updating, and 
            deleting data from session storage.
            </summary>
            <typeparam name="T">The type of data stored in session storage.</typeparam>
        </member>
        <member name="P:Microsoft.JSInterop.SessionStorageState`1.Key">
            <summary>
            The key used for this session storage state.
            </summary>
        </member>
        <member name="M:Microsoft.JSInterop.SessionStorageState`1.#ctor(Microsoft.JSInterop.SessionStorageFactoryService,System.String)">
            <summary>
            Create a session storage state for a specific <paramref name="key"/> and 
            using the <paramref name="service"/> factory.
            </summary>
            <param name="service">Factory for manageing the session storage operations.</param>
            <param name="key">The key used in session storage.</param>
        </member>
        <member name="M:Microsoft.JSInterop.SessionStorageState`1.GetAsync(System.Threading.CancellationToken)">
            <summary>
            Get data from session storage.
            </summary>
            <param name="cancellationToken"><seealso cref="T:System.Threading.CancellationToken"/></param>
            <returns>A task getting the session storage and returning the data.</returns>
        </member>
        <member name="M:Microsoft.JSInterop.SessionStorageState`1.SetAsync(`0,System.Threading.CancellationToken)">
            <summary>
            Add or update data from session storage.
            </summary>
            <param name="data">Data to be stored in session storage.</param>
            <param name="cancellationToken"><seealso cref="T:System.Threading.CancellationToken"/></param>
            <returns>A task adding or updating the session storage data.</returns>
        </member>
        <member name="M:Microsoft.JSInterop.SessionStorageState`1.DeleteAsync(System.Threading.CancellationToken)">
            <summary>
            Delete data from session storage.
            </summary>
            <param name="cancellationToken"><seealso cref="T:System.Threading.CancellationToken"/></param>
            <returns>A task deleting the session storage data.</returns>
        </member>
        <member name="T:Serilog.LogStackTrace">
            <summary>
            Extension methods for logging stack traces not 
            associated with an exception.
            </summary>
        </member>
        <member name="M:Serilog.LogStackTrace.StackTrace``1(Serilog.ILogger,System.String,``0,System.UInt16)">
            <inheritdoc cref="M:Serilog.LogStackTrace.StackTrace``1(Serilog.ILogger,System.String,System.Object,``0,System.UInt16)"/>
        </member>
        <member name="M:Serilog.LogStackTrace.StackTrace``1(Serilog.ILogger,System.String,System.Object,``0,System.UInt16)">
            <summary>
            Log results for debugging if debug logging is enabled.
            <inheritdoc cref="M:Serilog.LogStackTrace.StackTrace(Serilog.ILogger,System.UInt16)" />
            </summary>
            <typeparam name="T">A type generic for passing through the results for chaining purposes.</typeparam>
            <param name="logger"><inheritdoc cref="M:Serilog.LogStackTrace.StackTrace(Serilog.ILogger,System.UInt16)"/></param>
            <param name="target">An custom identifier for what this log is being called against.</param>
            <param name="data">Additional details that should be logged with stack trace for debugging.</param>
            <param name="result">The interesting data to be returned after logging.</param>
            <param name="skipFrames"><inheritdoc cref="M:Serilog.LogStackTrace.StackTrace(Serilog.ILogger,System.UInt16)"/></param>
            <returns>The <paramref name="result"/> passed in without modifications.</returns>
        </member>
        <member name="M:Serilog.LogStackTrace.StackTrace(Serilog.ILogger,System.UInt16)">
            <summary>
            Log a stack trace at the point of caller if verbose logging is enabled.
            </summary>
            <param name="logger">The serilog logger.</param>
            <param name="skipFrames">Number of stack frames to ignore. This is usuful if wanting to ignore a part of the stack frame because the caller is not the important part of the stack frame.</param>
        </member>
        <member name="T:System.ComponentModel.EnumExtensions">
            <summary>
            Simplified attribute getter for enums.
            </summary>
        </member>
        <member name="M:System.ComponentModel.EnumExtensions.GetDescription``1(``0)">
            <summary>
            Get the description value of the attribute if it exists. Otherwise
            return the attribute string representation.
            </summary>
            <typeparam name="TEnum">The type of the target enum to search for an attribute on.</typeparam>
            <param name="enumerationValue">The target enum to search for an attribute on.</param>
            <returns>A string value for the description associated with the enum or the string value.</returns>
        </member>
        <member name="M:System.ComponentModel.EnumExtensions.GetAttribute``3(``0,System.Func{System.String,``1,``2})">
            <summary>
            Get a specific attribute from an enum.
            </summary>
            <typeparam name="TEnum">The type of the target enum to search for an attribute on.</typeparam>
            <typeparam name="TAttribute">The attribute type to search for.</typeparam>
            <typeparam name="TResult">The type that should be returned.</typeparam>
            <param name="enumerationValue">The target enum to search for an attribute on.</param>
            <param name="callback">A method which takes in the stringified version of the <paramref name="enumerationValue"/> and the attribute attached to the enum value and returns a <typeparamref name="TResult"/>.</param>
            <returns>The results of the <paramref name="callback"/>.</returns>
            <exception cref="T:System.ArgumentException">If <paramref name="enumerationValue"/> is not an enum.</exception>
            <exception cref="T:System.InvalidOperationException">If <paramref name="enumerationValue"/> does not return a string value.</exception>
        </member>
        <member name="T:System.IO.EmbeddedResource">
            <summary>
            Helper to get Embedded resources by filename.
            </summary>
        </member>
        <member name="M:System.IO.EmbeddedResource.ReadAsync``1(System.String,System.Threading.CancellationToken)">
            <inheritdoc cref="M:System.IO.EmbeddedResource.ReadAsync``1(System.String,System.Text.Json.JsonSerializerOptions,System.Reflection.Assembly,System.Threading.CancellationToken)"/>
        </member>
        <member name="M:System.IO.EmbeddedResource.ReadAsync``1(System.String,System.Reflection.Assembly,System.Threading.CancellationToken)">
            <inheritdoc cref="M:System.IO.EmbeddedResource.ReadAsync``1(System.String,System.Text.Json.JsonSerializerOptions,System.Reflection.Assembly,System.Threading.CancellationToken)"/>
        </member>
        <member name="M:System.IO.EmbeddedResource.ReadAsync``1(System.String,System.Text.Json.JsonSerializerOptions,System.Threading.CancellationToken)">
            <inheritdoc cref="M:System.IO.EmbeddedResource.ReadAsync``1(System.String,System.Text.Json.JsonSerializerOptions,System.Reflection.Assembly,System.Threading.CancellationToken)"/>
        </member>
        <member name="M:System.IO.EmbeddedResource.ReadAsync``1(System.String,System.Text.Json.JsonSerializerOptions,System.Reflection.Assembly,System.Threading.CancellationToken)">
            <inheritdoc cref = "M:System.IO.EmbeddedResource.ReadAsync``1(System.String,System.Text.Json.JsonSerializerOptions,System.Collections.Generic.IEnumerable{System.Reflection.Assembly},System.Threading.CancellationToken)" />
            <param name="filename"><inheritdoc cref="M:System.IO.EmbeddedResource.ReadAsync``1(System.String,System.Text.Json.JsonSerializerOptions,System.Collections.Generic.IEnumerable{System.Reflection.Assembly},System.Threading.CancellationToken)"/></param>
            <param name="options"><inheritdoc cref="M:System.IO.EmbeddedResource.ReadAsync``1(System.String,System.Text.Json.JsonSerializerOptions,System.Collections.Generic.IEnumerable{System.Reflection.Assembly},System.Threading.CancellationToken)"/></param>
            <param name="assembly"><inheritdoc cref="M:System.IO.EmbeddedResource.ReadAsync``1(System.String,System.Text.Json.JsonSerializerOptions,System.Collections.Generic.IEnumerable{System.Reflection.Assembly},System.Threading.CancellationToken)"/></param>
            <param name="cancellationToken"><inheritdoc cref="M:System.IO.EmbeddedResource.ReadAsync``1(System.String,System.Text.Json.JsonSerializerOptions,System.Collections.Generic.IEnumerable{System.Reflection.Assembly},System.Threading.CancellationToken)"/></param>
        </member>
        <member name="M:System.IO.EmbeddedResource.ReadAsync``1(System.String,System.Collections.Generic.IEnumerable{System.Reflection.Assembly},System.Threading.CancellationToken)">
            <inheritdoc cref="M:System.IO.EmbeddedResource.ReadAsync``1(System.String,System.Text.Json.JsonSerializerOptions,System.Collections.Generic.IEnumerable{System.Reflection.Assembly},System.Threading.CancellationToken)"/>
        </member>
        <member name="M:System.IO.EmbeddedResource.ReadAsync``1(System.String,System.Text.Json.JsonSerializerOptions,System.Collections.Generic.IEnumerable{System.Reflection.Assembly},System.Threading.CancellationToken)">
            <summary>
            Read content from a file into a json object and deserialize it into an object of type
            <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">The type of object to be returned.</typeparam>
            <param name="filename"><inheritdoc cref="M:System.IO.EmbeddedResource.ReadAllTextAsync(System.String,System.Reflection.Assembly)"/></param>
            <param name="options">Options for the json deserialization process.</param>
            <param name="assemblies">Additional assemblies to search first before the default locations.</param>
            <param name="cancellationToken">A token for cancelling the async process early.</param>
            <returns>The embedded resource as a C# object.</returns>
        </member>
        <member name="M:System.IO.EmbeddedResource.ReadAllTextAsync(System.String,System.Reflection.Assembly)">
            <summary>
            Read all the text from an embedded resource.
            </summary>
            <param name="filename">The name of the file as it exists on disk. This does not need to be namespaced unless there are duplicate files in seperate assemblies.</param>
            <param name="assembly">An assembly to search first before the default locations.</param>
            <returns>The embedded resource contents as a string or null if no content was found.</returns>
        </member>
        <member name="M:System.IO.EmbeddedResource.ReadAllTextAsync(System.String,System.Collections.Generic.IEnumerable{System.Reflection.Assembly})">
            <summary>
            <inheritdoc cref="M:System.IO.EmbeddedResource.ReadAllTextAsync(System.String,System.Reflection.Assembly)"/>
            </summary>
            <param name="filename"><inheritdoc cref="M:System.IO.EmbeddedResource.ReadAllTextAsync(System.String,System.Reflection.Assembly)"/></param>
            <param name="assemblies">Additional assemblies to search first before the default locations.</param>
            <returns><inheritdoc cref="M:System.IO.EmbeddedResource.ReadAllTextAsync(System.String,System.Reflection.Assembly)"/></returns>
        </member>
        <member name="M:System.IO.EmbeddedResource.ReadStreamAsync(System.String,System.Reflection.Assembly)">
            <summary>
            Get a stream reader for the given embedded resource filename.
            </summary>
            <param name="filename"><inheritdoc cref="M:System.IO.EmbeddedResource.ReadAllTextAsync(System.String,System.Reflection.Assembly)"/></param>
            <param name="assembly"><inheritdoc cref="M:System.IO.EmbeddedResource.ReadAllTextAsync(System.String,System.Reflection.Assembly)"/></param>
            <returns><inheritdoc cref="M:System.IO.EmbeddedResource.ReadAllTextAsync(System.String,System.Reflection.Assembly)"/></returns>
        </member>
        <member name="M:System.IO.EmbeddedResource.ReadStreamAsync(System.String,System.Collections.Generic.IEnumerable{System.Reflection.Assembly})">
            <summary>
            <inheritdoc cref="M:System.IO.EmbeddedResource.ReadStreamAsync(System.String,System.Reflection.Assembly)"/>
            </summary>
            <param name="filename"><inheritdoc cref="M:System.IO.EmbeddedResource.ReadStreamAsync(System.String,System.Reflection.Assembly)"/></param>
            <param name="assemblies">Additional assemblies to search first before the default locations.</param>
            <returns><inheritdoc cref="M:System.IO.EmbeddedResource.ReadStreamAsync(System.String,System.Reflection.Assembly)"/></returns>
        </member>
        <member name="M:System.IO.EmbeddedResource.GetAllFilenames(System.Reflection.Assembly)">
            <summary>
            Get all assembly manifest resource names. This is using
            <seealso cref="M:System.Reflection.Assembly.GetManifestResourceNames"/> to retrieve
            all the names.
            </summary>
            <param name="assembly">An assembly to get manifest resource names from.</param>
            <returns>A list of manifest resource names.</returns>
        </member>
        <member name="M:System.IO.EmbeddedResource.GetAllFilenames(System.Collections.Generic.IEnumerable{System.Reflection.Assembly})">
            <summary>
            <inheritdoc cref="M:System.IO.EmbeddedResource.GetAllFilenames(System.Reflection.Assembly)"/>
            </summary>
            <param name="assemblies">List of assemblies to get manifest resource names from.</param>
            <returns><inheritdoc cref="M:System.IO.EmbeddedResource.GetAllFilenames(System.Reflection.Assembly)"/></returns>
        </member>
        <member name="T:System.Linq.LinqExtensions">
            <summary>
            Linq extension methods.
            </summary>
        </member>
        <member name="M:System.Linq.LinqExtensions.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>
            Linq method to iterate over all items in a <paramref name="list"/> and
            calling <paramref name="predicate"/> on each item.
            </summary>
            <typeparam name="TModel">Generic type list of objects to add a single item to.</typeparam>
            <typeparam name="TResult">The type to return from the <paramref name="predicate"/>.</typeparam>
            <param name="list">List of items to have single item added to.</param>
            <param name="predicate">A method to convert an each item in list to a string.</param>
        </member>
        <member name="M:System.Linq.LinqExtensions.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>
            Linq method to iterate over all items in a <paramref name="list"/> and
            calling <paramref name="predicate"/> on each item.
            </summary>
            <typeparam name="T">Generic type list of objects to add a single item to.</typeparam>
            <param name="list">List of items to have single item added to.</param>
            <param name="predicate">A method to convert an each item in list to a string.</param>
        </member>
        <member name="M:System.Linq.LinqExtensions.ForEach``2(``0[],System.Func{``0,``1})">
            <summary>
            Linq method to iterate over all items in a <paramref name="list"/> and
            calling <paramref name="predicate"/> on each item.
            </summary>
            <typeparam name="TModel">Generic type list of objects to add a single item to.</typeparam>
            <typeparam name="TResult">The type to return from the <paramref name="predicate"/>.</typeparam>
            <param name="list">List of items to have single item added to.</param>
            <param name="predicate">A method to convert an each item in list to a string.</param>
        </member>
        <member name="M:System.Linq.LinqExtensions.ForEach``1(``0[],System.Action{``0})">
            <summary>
            Linq method to iterate over all items in a <paramref name="list"/> and
            calling <paramref name="predicate"/> on each item.
            </summary>
            <typeparam name="T">Generic type list of objects to add a single item to.</typeparam>
            <param name="list">List of items to have single item added to.</param>
            <param name="predicate">A method to convert an each item in list to a string.</param>
        </member>
        <member name="M:System.Linq.LinqExtensions.Join(System.Collections.Generic.IEnumerable{System.String},System.String)">
            <summary>
            General method to flatten a <paramref name="list"/> into a string of 
            each string in list and seperated by <paramref name="seperator"/>.
            </summary>
            <param name="list">List of items to have single item added to.</param>
            <param name="seperator">The string seperater to place between each item.</param>
            <returns>String converted of <paramref name="list"/> and joined by <paramref name="seperator"/>.</returns>
        </member>
        <member name="M:System.Linq.LinqExtensions.Flatten``1(System.Collections.Generic.IEnumerable{``0},System.String,System.Func{``0,System.String})">
            <summary>
            General method to flatten a <paramref name="list"/> into a string of 
            each item converted and seperated by <paramref name="seperator"/>.
            </summary>
            <typeparam name="T">Generic type list of objects to add a single item to.</typeparam>
            <param name="list">List of items to have single item added to.</param>
            <param name="seperator">The string seperater to place between each item.</param>
            <param name="predicate">A method to convert an each item in list to a string.</param>
            <returns>String converted of <paramref name="list"/> and joined by <paramref name="seperator"/>.</returns>
        </member>
        <member name="M:System.Linq.LinqExtensions.UnionIf``1(System.Collections.Generic.IEnumerable{``0},System.Func{System.Boolean},``0)">
            <summary>
            Linq extension to conditionally join a object to a list of similar 
            objects.
            </summary>
            <typeparam name="T">Generic type list of objects to add a single item to.</typeparam>
            <param name="list">List of items to have single item added to.</param>
            <param name="conditional">Callback to determine if <paramref name="item"/> should be added to the list or not.</param>
            <param name="item">The item to add to the list.</param>
            <returns></returns>
        </member>
        <member name="M:System.Linq.LinqExtensions.UnionIf``1(System.Collections.Generic.IEnumerable{``0},System.Func{System.Boolean},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Linq extension to conditionally join a list of objects to another list 
            of similar objects.
            </summary>
            <typeparam name="T">Generic type list of objects to add a single item to.</typeparam>
            <param name="list">List of items to have single item added to.</param>
            <param name="conditional">Callback to determine if <paramref name="items"/> should be added to the list or not.</param>
            <param name="items">The list of items to add to the list.</param>
            <returns></returns>
        </member>
        <member name="M:System.Linq.LinqExtensions.Union``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary>
            Linq extension to union/join an object to a list.
            </summary>
            <typeparam name="T">Generic type list of objects to add a single item to.</typeparam>
            <param name="list">List of items to have single item added to.</param>
            <param name="item">The item to add to the list.</param>
            <returns>The list with the item added to it.</returns>
        </member>
        <member name="T:System.Net.Http.EnhancedLimitedHttpClient">
            <summary>
            Class for enhancing the base HttpClient.
            </summary>
        </member>
        <member name="P:System.Net.Http.EnhancedLimitedHttpClient.BaseAddress">
            <summary>
            The base address of all calls that the endpoints will use as a reference.
            </summary>
        </member>
        <member name="M:System.Net.Http.EnhancedLimitedHttpClient.#ctor(Serilog.ILogger,System.Net.Http.HttpClient)">
            <summary>
            Converts an HttpClient into a restricted version that has enhanced
            methods for getting data.
            </summary>
            <param name="logger">Serilog Logger</param>
            <param name="client">HttpClient to use for making calls.</param>
        </member>
        <member name="M:System.Net.Http.EnhancedLimitedHttpClient.GetJsonAsync``1(System.String,System.Threading.CancellationToken)">
            <summary>
            Get object from <paramref name="url"/> and throws a 
            <seealso cref="T:System.NullReferenceException"/> if object is null or un able 
            to be converted to <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">The type of the object that shoudld be returned.</typeparam>
            <param name="url">The end point to get data back from using a GET method using json.</param>
            <param name="cancellationToken">Cancelation token.</param>
            <returns></returns>
            <exception cref="T:System.NullReferenceException">Throw if the object returned is null.</exception>
        </member>
        <member name="M:System.Net.Http.EnhancedLimitedHttpClient.GetJsonAsync``1(System.String,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Get object from <paramref name="url"/> and allow null result
            if <paramref name="allowNulls"/> is true. Throws a 
            <seealso cref="T:System.NullReferenceException"/> if object is null or un able 
            to be converted to <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">The type of the object that shoudld be returned.</typeparam>
            <param name="url">The end point to get data back from using a GET method using json.</param>
            <param name="allowNulls">If true, allow for nulls to be returned else throw null reference exception.</param>
            <param name="cancellationToken">Cancelation token.</param>
            <returns></returns>
            <exception cref="T:System.NullReferenceException">Throw if the <paramref name="allowNulls"/> is false and the object returned is null.</exception>
        </member>
        <member name="T:System.Net.Http.HttpClientFactoryExtensions">
            <summary>
            <seealso cref="T:System.Net.Http.IHttpClientFactory"/> extension method helpers.
            </summary>
        </member>
        <member name="M:System.Net.Http.HttpClientFactoryExtensions.GetClient(System.Net.Http.IHttpClientFactory,System.String)">
            <summary>
            Get an <seealso cref="T:System.Net.Http.EnhancedLimitedHttpClient"/> by calling the 
            create client method 
            </summary>
            <param name="factory">A factory abstraction for creating HttpClients.</param>
            <param name="name">The logical name of the client to create.</param>
            <returns>A <seealso cref="T:System.Net.Http.EnhancedLimitedHttpClient"/> created with the <seealso cref="M:System.Net.Http.IHttpClientFactory.CreateClient(System.String)"/>.</returns>
        </member>
        <member name="T:System.Security.Claims.SerializableClaim">
            <summary>
            Create a simple claim that is useful for serializing and deserializing.
            </summary>
        </member>
        <member name="P:System.Security.Claims.SerializableClaim.Type">
            <summary>
            This is the key of the key/value claim.
            </summary>
        </member>
        <member name="P:System.Security.Claims.SerializableClaim.Value">
            <summary>
            The value of the claim.
            </summary>
        </member>
        <member name="P:System.Security.Claims.SerializableClaim.Issuer">
            <summary>
            The issuer of the claim.
            </summary>
        </member>
        <member name="M:System.Security.Claims.SerializableClaim.#ctor">
            <summary>
            Create a simple claim without any data. This constructor is intended
            for deserializing a json object.
            </summary>
        </member>
        <member name="M:System.Security.Claims.SerializableClaim.#ctor(System.String,System.String,System.String)">
            <summary>
            Create a simple claim with an issuer.
            </summary>
            <param name="type">This is the key of the key/value claim.</param>
            <param name="value">The value of the claim.</param>
            <param name="issuer">The issuer of the claim.</param>
        </member>
        <member name="M:System.Security.Claims.SerializableClaim.#ctor(System.String,System.String)">
            <summary>
            Create a simple claim without an issuer.
            </summary>
            <param name="type">This is the key of the key/value claim.</param>
            <param name="value">The value of the claim.</param>
        </member>
        <member name="M:System.Security.Claims.SerializableClaim.#ctor(System.Security.Claims.Claim)">
            <summary>
            Create a simple claim from <seealso cref="T:System.Security.Claims.Claim"/>.
            </summary>
            <param name="claim">A <seealso cref="T:System.Security.Claims.Claim"/> to be simplified.</param>
        </member>
        <member name="M:System.Security.Claims.SerializableClaim.AsClaim">
            <summary>
            Convert simple claim into a <seealso cref="T:System.Security.Claims.Claim"/>.
            </summary>
            <returns><seealso cref="T:System.Security.Claims.Claim"/> of simple type.</returns>
        </member>
        <member name="M:System.Security.Claims.SerializableClaim.Equals(System.Object)">
            <summary>
            Checks to see if one <seealso cref="T:System.Security.Claims.SerializableClaim" /> has
            the same <see cref="P:System.Security.Claims.SerializableClaim.Type" /> and <see cref="P:System.Security.Claims.SerializableClaim.Value" /> as another 
            <seealso cref="T:System.Security.Claims.SerializableClaim" />.
            </summary>
            <param name="obj">The other <seealso cref="T:System.Security.Claims.SerializableClaim" /> to compare with.</param>
            <returns>Returns true if the <see cref="P:System.Security.Claims.SerializableClaim.Type" /> and <see cref="P:System.Security.Claims.SerializableClaim.Value" /> from both <seealso cref="T:System.Security.Claims.SerializableClaim" /> objects are the the same.</returns>
        </member>
        <member name="M:System.Security.Claims.SerializableClaim.GetHashCode">
            <inheritdoc cref="M:System.Type.GetHashCode" />
        </member>
        <member name="T:System.Text.ByteEncodingExtensions">
            <summary>
            Generic extension methods for simplifing byte encoding and
            decoding to and from strings.
            </summary>
        </member>
        <member name="M:System.Text.ByteEncodingExtensions.ToBase64ByteEncodedString``1(``0)">
            <summary>
            Convert <paramref name="data"/> into a json string and 
            byte encode into a UTF32 encoded string.
            </summary>
            <typeparam name="T">The type of an object that should be byte encoded into a UTF32 encoded string.</typeparam>
            <param name="data">An object that should be byte encoded into a UTF32 encoded string.</param>
            <returns>String UTF32 byte encoded string of an object.</returns>
            <exception cref="T:System.NullReferenceException">Throws null if the object is null.</exception>
        </member>
        <member name="M:System.Text.ByteEncodingExtensions.FromBase64ByteEncodedString``1(System.String)">
            <summary>
            Extract object from a UTF32 encoded string.
            </summary>
            <typeparam name="T">The type of an object that should be return from the byte encoded UTF32 encoded string.</typeparam>
            <param name="json">UTF32 byte encoded string to be decoded.</param>
            <returns>An object decoded from the UTF32 byte encoded string.</returns>
        </member>
        <member name="T:System.Text.Json.JsonSerializerDotNetLibrary">
            <summary>
            Json serialization and deserialization helper extension methods.
            </summary>
        </member>
        <member name="M:System.Text.Json.JsonSerializerDotNetLibrary.DefaultOptions">
            <summary>
            Get the default options configuration object used for calls that 
            do not supply an options object or option callback method.
            </summary>
            <returns>The default configuration.</returns>
        </member>
        <member name="M:System.Text.Json.JsonSerializerDotNetLibrary.DefaultOptions(System.Action{System.Text.Json.JsonSerializerOptions})">
            <summary>
            Get the default options configuration object and mutate it with
            the <paramref name="optionsCallback"/>.
            </summary>
            <param name="optionsCallback">Callback to mutate the default options before passing it to the Serializer or Deserializer.</param>
            <returns>The mutated default configuration.</returns>
        </member>
        <member name="M:System.Text.Json.JsonSerializerDotNetLibrary.ToJsonString``1(``0)">
            <summary>
            Convert target object into a JSON serialized string.
            </summary>
            <typeparam name="T">Any object type can be converted.</typeparam>
            <param name="data">Object that should be serialized to a json string.</param>
            <returns>JSON string of the object.</returns>
        </member>
        <member name="M:System.Text.Json.JsonSerializerDotNetLibrary.ToJsonString``1(``0,System.Boolean)">
            <summary>
            Convert target object into a JSON serialized string.
            </summary>
            <typeparam name="T">Any object type can be converted.</typeparam>
            <param name="data">Object that should be serialized to a json string.</param>
            <param name="writeIndented">Should it be formatted with tabs and returns.</param>
            <returns>JSON string of the object.</returns>
        </member>
        <member name="M:System.Text.Json.JsonSerializerDotNetLibrary.ToJsonString``1(``0,System.Text.Json.JsonSerializerOptions)">
            <summary>
            Convert target object into a JSON serialized string.
            </summary>
            <typeparam name="T">Any object type can be converted.</typeparam>
            <param name="data">Object that should be serialized to a json string.</param>
            <param name="options">JsonSerializerOptions configuration for serializing the object into a string.</param>
            <returns>JSON string of the object.</returns>
        </member>
        <member name="M:System.Text.Json.JsonSerializerDotNetLibrary.ToJsonString``1(``0,System.Action{System.Text.Json.JsonSerializerOptions})">
            <summary>
            Convert target object into a JSON serialized string.
            </summary>
            <typeparam name="T">Any object type can be converted.</typeparam>
            <param name="data">Object that should be serialized to a json string.</param>
            <param name="optionsCallback">Callback to configure json serializer options.</param>
            <returns>JSON string of the object.</returns>
        </member>
        <member name="M:System.Text.Json.JsonSerializerDotNetLibrary.FromJsonString``1(System.String,System.Text.Json.JsonSerializerOptions)">
            <summary>
            Convert a json string into an object.
            </summary>
            <typeparam name="T">Any object type can be converted.</typeparam>
            <param name="json">A string json representation to be converted into an object.</param>
            <param name="options">Options for <seealso cref="M:System.Text.Json.JsonSerializer.Deserialize(System.String,System.Type,System.Text.Json.JsonSerializerOptions)"/>.</param>
            <returns>The object that is returned from deserializing the json string.</returns>
        </member>
        <member name="M:System.Text.Json.JsonSerializerDotNetLibrary.FromJsonStringUsingModel``1(System.String,``0,System.Text.Json.JsonSerializerOptions)">
            <summary>
            Convert a json string into an object.
            </summary>
            <typeparam name="T">Any object type can be converted.</typeparam>
            <param name="json">A string json representation to be converted into an object.</param>
            <param name="model">A target type to convert the json string into.</param>
            <param name="options"><inheritdoc cref="M:System.Text.Json.JsonSerializerDotNetLibrary.ToJsonString``1(``0)"/></param>
            <returns>The object that is returned from deserializing the json string.</returns>
        </member>
        <member name="M:System.Text.Json.JsonSerializerDotNetLibrary.FromJsonStringUsingType(System.String,System.Type,System.Text.Json.JsonSerializerOptions)">
            <summary>
            Convert a json string into an object.
            </summary>
            <param name="json">A string json representation to be converted into an object.</param>
            <param name="type">A target type to convert the json string into.</param>
            <param name="options"><inheritdoc cref="M:System.Text.Json.JsonSerializerDotNetLibrary.ToJsonString``1(``0)"/></param>
            <returns>The object that is returned from deserializing the json string.</returns>
        </member>
        <member name="M:System.Text.Json.JsonSerializerDotNetLibrary.FromJsonStreamAsync``1(System.Threading.Tasks.Task{System.IO.Stream},System.Threading.CancellationToken)">
            <summary>
            Convert a json string into an object.
            </summary>
            <typeparam name="T">Any object type can be converted.</typeparam>
            <param name="stream">A stream of data that represents a json string of an object.</param>
            <param name="cancellationToken">Cancellation token.</param>
            <returns>The object that is returned from deserializing the json string.</returns>
            <exception cref="T:System.NullReferenceException">If allowNull is false and the json string deserializes into a null object, this exception is thrown.</exception>
        </member>
        <member name="M:System.Text.Json.JsonSerializerDotNetLibrary.FromJsonStreamAsync``1(System.Threading.Tasks.Task{System.IO.Stream},System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Convert a json string into an object.
            </summary>
            <typeparam name="T">Any object type can be converted.</typeparam>
            <param name="stream">A stream of data that represents a json string of an object.</param>
            <param name="allowNull">Allow a null value or object to be returned. True to allow nulls, and false to throw null exception error.</param>
            <param name="cancellationToken">Cancellation token.</param>
            <returns>The object that is returned from deserializing the json string.</returns>
            <exception cref="T:System.NullReferenceException">If allowNull is false and the json string deserializes into a null object, this exception is thrown.</exception>
        </member>
        <member name="T:System.Text.Json.Serialization.JsonListStringConverter">
            <summary>
            Converter for lists of strings to and from json strings.
            </summary>
        </member>
        <member name="M:System.Text.Json.Serialization.JsonListStringConverter.Read(System.Text.Json.Utf8JsonReader@,System.Type,System.Text.Json.JsonSerializerOptions)">
            <summary>
            Read a comma seperated string array from reader.
            </summary>
            <param name="reader">Utf8JsonReader</param>
            <param name="typeToConvert">typeof(List&lt;string&gt;)</param>
            <param name="options">JsonSerializerOptions</param>
            <returns>A list of strings from a comma seperated string array.</returns>
        </member>
        <member name="M:System.Text.Json.Serialization.JsonListStringConverter.Write(System.Text.Json.Utf8JsonWriter,System.Collections.Generic.List{System.String},System.Text.Json.JsonSerializerOptions)">
            <summary>
            Write string output of list of strings into a comma seperated string array.
            </summary>
            <param name="writer">Utf8JsonWriter</param>
            <param name="list">List of string to turn into comma seperated string array.</param>
            <param name="options">JsonSerializerOptions</param>
        </member>
        <member name="T:System.Text.Json.Serialization.JsonListStringConverterAttribute">
            <summary>
            Attribute for marking property of type of list of strings to use
            the jsoncoverter to change to comma list of string.
            </summary>
        </member>
        <member name="M:System.Text.Json.Serialization.JsonListStringConverterAttribute.#ctor">
            <summary>
            Constructor for attribute.
            </summary>
        </member>
        <member name="T:System.Text.StringExtensions">
            <summary>
            Generic extension methods for enhancing string functions.
            </summary>
        </member>
        <member name="M:System.Text.StringExtensions.WithSuffix(System.Int32,System.String)">
            <summary>
            Return the suffix of a number. 1st, 2nd, 3rd, etc.
            </summary>
            <param name="number">The number to format.</param>
            <param name="format">Additional formatting for the number.</param>
            <returns>The formatted number with the suffix added at the end.</returns>
        </member>
        <member name="M:System.Text.StringExtensions.SubstringClip(System.String,System.Int32)">
            <summary>
            Safely returns up to <paramref name="length"/> number of characters from 
            <paramref name="text"/>. Unlike the <see cref="M:System.String.Substring(System.Int32,System.Int32)"/> 
            with a start index of 0 which throws an error if the requested start and length 
            parameters are outside the bounds of the <paramref name="text"/>. This will also 
            return the original value if it is null or white space.
            </summary>
            <param name="text">The text to clip and return the first <paramref name="length"/> number of characters.</param>
            <param name="length">The maximum number of characters to return from the start <paramref name="text"/>.</param>
            <returns>Returns up to <paramref name="length"/> of characters from start of <paramref name="text"/>.</returns>
        </member>
        <member name="M:System.Text.StringExtensions.SubstringClip(System.String,System.Int32,System.Int32)">
            <summary>
            Safely returns up to <paramref name="length"/> number of characters starting at the
            <paramref name="startIndex"/> index of the <paramref name="text"/>. Unlike the 
            <see cref="M:System.String.Substring(System.Int32,System.Int32)"/> which throws an error if the requested start 
            or/and length parameters are outside the bounds of the <paramref name="text"/>. This 
            will also return the original value if it is null or white space or start is outside 
            the bounds of the <paramref name="text"/>.
            </summary>
            <param name="text">The text to clip and return the <paramref name="length"/> number of characters starting at the <paramref name="startIndex"/>.</param>
            <param name="startIndex">The first character position to start clipping.</param>
            <param name="length">The maximum number of characters to return from the <paramref name="startIndex"/> of the <paramref name="text"/>.</param>
            <returns>Returns up to <paramref name="length"/> of characters from the <paramref name="startIndex"/> of the <paramref name="text"/>.</returns>
        </member>
        <member name="M:System.Text.StringExtensions.ToTitleCase(System.String,System.Boolean)">
            <summary>
            Converts <paramref name="text"/> to title case (except for words that are 
            entirely in uppercase, which are considered to be acronyms). By default
            the text will first be expanded. This is useful for turning camel or Pascal
            case <paramref name="text"/> in prep to title case it.
            <example><code>ie: theQuickBrownFox_1Jumped|orRatherRan => the Quick Brown Fox_1 Jumped|or Rather Ran</code></example>
            </summary>
            <param name="text">The string to convert to title case.</param>
            <param name="expandWords">By default spaces are added before capital letters unless false is passed and the text is used as passed in.</param>
            <returns>The specified string converted to title case.</returns>
        </member>
        <member name="M:System.Text.StringExtensions.Mask(System.String,System.String,System.Char)">
            <summary>
            Mask a portion of the <paramref name="text"/> given a <paramref name="filter"/>.
            </summary>
            <param name="text">The string that should have the <paramref name="filter"/> applied to it.</param>
            <param name="filter">The string that should be masked out.</param>
            <param name="mask">The char to be used for masking out the <paramref name="filter"/> from the <paramref name="text"/>.</param>
            <returns>The <paramref name="text"/> with the <paramref name="filter"/> having been masked out with the <paramref name="mask"/> character.</returns>
        </member>
        <member name="M:System.Text.StringExtensions.Mask(System.String,System.String,System.Int32,System.Char)">
            <summary>
            <inheritdoc cref="M:System.Text.StringExtensions.Mask(System.String,System.String,System.Char)"/> Mask will be
            replaced by <paramref name="size"/> number of <paramref name="mask"/>.
            </summary>
            <param name="text"><inheritdoc cref="M:System.Text.StringExtensions.Mask(System.String,System.String,System.Char)"/></param>
            <param name="filter"><inheritdoc cref="M:System.Text.StringExtensions.Mask(System.String,System.String,System.Char)"/></param>
            <param name="mask"><inheritdoc cref="M:System.Text.StringExtensions.Mask(System.String,System.String,System.Char)"/></param>
            <param name="size">The number of characters that should replace the <paramref name="filter"/>.</param>
            <returns><inheritdoc/> Mask will only be <paramref name="size"/> characters.</returns>
        </member>
        <member name="M:System.Text.StringExtensions.Repeat(System.Char,System.Int32)">
            <summary>
            Take a <paramref name="character"/> and <paramref name="repeat"/> it a 
            specified number of times.<br/>
            <br/>
            ie: '*'.Repeat(5) == "*****"
            </summary>
            <param name="character">The character to be <paramref name="repeat"/>ed.</param>
            <param name="repeat">The number of times to repeat the <paramref name="character"/>.</param>
            <returns>The full string of <paramref name="character"/>'s that have been <paramref name="repeat"/>ed.</returns>
        </member>
        <member name="M:System.Text.StringExtensions.IndentLeft(System.String,System.Int32,System.Char,System.Int32)">
            <summary>
            Add a number of <paramref name="character"/>s to the left side of <paramref name="text"/>.
            </summary>
            <param name="text">The text to be indented.</param>
            <param name="indentLevel">The number of times <paramref name="indentSize"/> should be used for indention.</param>
            <param name="character">The character to use for indention.</param>
            <param name="indentSize">How many <paramref name="character"/> to use for each <paramref name="indentLevel"/>.</param>
            <returns>The <paramref name="text"/> with <paramref name="character"/>s prepended.</returns>
        </member>
    </members>
</doc>
